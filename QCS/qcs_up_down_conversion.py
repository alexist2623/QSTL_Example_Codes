	
	"""IQ Upconversion and Downconversion Example"""
	import keysight.qcs as qcs
	import numpy as np
	#################################################################
	# Basic constants for convenience
	#################################################################
	GHz     = 1e9
	ns      = 1e-9
	n_shots = 300
	#################################################################
	# Virtual Channel Definitions
	# awgs : M5300 AWG channels
	# digs : M5200 Digitizer channels
	#################################################################
	awgs    = qcs.Channels(
	    range(4),
	    name = "awgs",
	    absolute_phase=True
	)
	digs    = qcs.Channels(
	    range(4),
	    name = "digs",
	    absolute_phase=True
	)
	#################################################################
	# Program & Mapper Definition
	#################################################################
	mapper  = qcs.ChannelMapper()
	program = qcs.Program()
	#################################################################
	# Map virtual channels to physical addresses
	# awgs[0] -> M9046A chassis, slot 1, module 4, channel 1  M5300 AWG
	# awgs[1] -> M9046A chassis, slot 1, module 4, channel 2  M5300 AWG
	# awgs[2] -> M9046A chassis, slot 1, module 4, channel 3  M5300 AWG
	# awgs[3] -> M9046A chassis, slot 1, module 4, channel 4  M5300 AWG
	# digs[0] -> M9046A chassis, slot 1, module 18, channel 1 M5200 Digitizer
	# digs[1] -> M9046A chassis, slot 1, module 18, channel 2 M5200 Digitizer
	# digs[2] -> M9046A chassis, slot 1, module 18, channel 3 M5200 Digitizer
	# digs[3] -> M9046A chassis, slot 1, module 18, channel 4 M5200 Digitizer
	#################################################################
	mapper.add_channel_mapping(
	    channels    = awgs,
	    addresses   = [
	        # Same with writing qcs.Address(1, 4, 1), ..., qcs.Address(1, 4, 4)
	        (1, 4, 1), (1, 4, 2), (1, 4, 3), (1, 4, 4)
	    ],
	    instrument_types = qcs.InstrumentEnum.M5300AWG
	)
	mapper.add_channel_mapping(
	    channels    = digs,
	    addresses   = [
	        # Same with writing qcs.Address(1, 18, 1), ..., qcs.Address(1, 18, 4)
	        (1,18,1), (1,18,2), (1,18,3), (1,18,4)
	    ],
	    instrument_types = qcs.InstrumentEnum.M5200Digitizer
	)
	#################################################################
	# Set LO frequencies for M5300 AWG and M5201 downconverter
	# and connect the M5201 downconverter to the M5200 digitizer
	# M5201 Ch 1 -> M5200 Ch 1
	#################################################################
	mapper.set_lo_frequencies(
	    addresses   = [
	        (1,4,1)
	    ],
	    lo_frequency = 9.237 * GHz
	)
	mapper.set_lo_frequencies(
	    addresses = [
	        (1,4,2), (1,4,3), (1,4,4)
	    ],
	    lo_frequency = 0 * GHz
	)
	mapper.add_downconverters(
	    dig_addresses=[
	        (1, 18, 1)
	    ],
	    downcon_addresses=[
	        (1, 17, 1)
	    ]
	)
	mapper.set_lo_frequencies(
	    addresses   = [
	        (1, 17, 1)
	    ],
	    lo_frequency= 9.286 * GHz
	)
	##################################################################
	# Declare saclar vairable which can be sweeped
	##################################################################
	duration = qcs.Scalar(
	    name  = "duration",
	    value = 200 * ns,
	    dtype = float
	)
	phase    = qcs.Scalar(
	    name  = "phase",
	    value = 0.0,
	    dtype = float
	)
	amplitude = qcs.Scalar(
	    name  = "amplitude",
	    value = 1.0,
	    dtype = float
	)
	##################################################################
	# Create the waveform for the M5300 AWG, and integration filter
	# function to get IQ demodulated data from the M5200 digitizer
	##################################################################
	iq_pulse_awg = qcs.RFWaveform(
	    duration        = duration,
	    envelope        = qcs.ConstantEnvelope(),
	    instantaneous_phase= phase,
	    amplitude       = amplitude,
	    # Note that rf_frequency should be set to final frequency,
	    # not the IF frequency. Its baseband waveform is automatically
	    # generated by QCS library.
	    rf_frequency    = 9.791 * GHz
	)
	iq_pulse_dig = qcs.RFWaveform(
	    duration        = duration + 100 *ns,
	    envelope        = qcs.ConstantEnvelope(),
	    instantaneous_phase= 0.0,
	    amplitude       = 1.0,
	    rf_frequency    = 9.791 * GHz
	)
	##################################################################
	# Program Sequence
	##################################################################
	program.add_waveform(
	    iq_pulse_awg,
	    awgs[0],
	    new_layer = True
	)
	program.add_acquisition(
	    iq_pulse_dig,
	    digs[0]
	)
	##################################################################
	# Set the number of shots
	##################################################################
	program.n_shots(n_shots)
	##################################################################
	# Variable for sweep
	##################################################################
	amplitudes = qcs.Array(
	    name="amplitudes",
	    value = [0.25, 0.5, 0.75, 1.0]
	)
	phases = qcs.Array(
	    name = "phases",
	    value = [np.pi * i / 4 for i in range(8)]
	)
	##################################################################
	# Sweep the qcs.Scalar variable with qcs.Array variable
	##################################################################
	program.sweep(amplitudes, amplitude)
	program.sweep(phases, phase)
	backend = qcs.HclBackend( 
	    channel_mapper  =mapper,
	    init_time       =0.001,
	    hw_demod        =False,
	    # Phase should be reseted before each shot to get
	    # correct IQ demodulated data.
	    reset_phase_every_shot=True
	)
	##################################################################
	# Execute the program and save the results
	##################################################################
	program_run = qcs.Executor(backend).execute(program)
	program_run.to_hdf5("downconvertor.hdf5")
	html_str = program_run.plot_iq().to_html()
	##################################################################
	# Save IQ demodulated data as HTML file
	##################################################################
	with open("downconvertor_iq.html","w", encoding='utf-8') as f:
	    f.write(html_str)
	    f.close()
	
